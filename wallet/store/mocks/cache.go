// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/sbuttigieg/test-quik-tech/wallet/store"
	"sync"
	"time"
)

// Ensure, that CacheMock does implement store.Cache.
// If this is not the case, regenerate this file with moq.
var _ store.Cache = &CacheMock{}

// CacheMock is a mock implementation of store.Cache.
//
// 	func TestSomethingThatUsesCache(t *testing.T) {
//
// 		// make and configure a mocked store.Cache
// 		mockedCache := &CacheMock{
// 			GetKeyBytesFunc: func(s string) ([]byte, bool) {
// 				panic("mock out the GetKeyBytes method")
// 			},
// 			GetKeyInt64Func: func(s string) (int64, bool) {
// 				panic("mock out the GetKeyInt64 method")
// 			},
// 			GetKeyStringFunc: func(s string) (string, bool) {
// 				panic("mock out the GetKeyString method")
// 			},
// 			SetKeyFunc: func(s string, ifaceVal interface{}, duration time.Duration) error {
// 				panic("mock out the SetKey method")
// 			},
// 		}
//
// 		// use mockedCache in code that requires store.Cache
// 		// and then make assertions.
//
// 	}
type CacheMock struct {
	// GetKeyBytesFunc mocks the GetKeyBytes method.
	GetKeyBytesFunc func(s string) ([]byte, bool)

	// GetKeyInt64Func mocks the GetKeyInt64 method.
	GetKeyInt64Func func(s string) (int64, bool)

	// GetKeyStringFunc mocks the GetKeyString method.
	GetKeyStringFunc func(s string) (string, bool)

	// SetKeyFunc mocks the SetKey method.
	SetKeyFunc func(s string, ifaceVal interface{}, duration time.Duration) error

	// calls tracks calls to the methods.
	calls struct {
		// GetKeyBytes holds details about calls to the GetKeyBytes method.
		GetKeyBytes []struct {
			// S is the s argument value.
			S string
		}
		// GetKeyInt64 holds details about calls to the GetKeyInt64 method.
		GetKeyInt64 []struct {
			// S is the s argument value.
			S string
		}
		// GetKeyString holds details about calls to the GetKeyString method.
		GetKeyString []struct {
			// S is the s argument value.
			S string
		}
		// SetKey holds details about calls to the SetKey method.
		SetKey []struct {
			// S is the s argument value.
			S string
			// IfaceVal is the ifaceVal argument value.
			IfaceVal interface{}
			// Duration is the duration argument value.
			Duration time.Duration
		}
	}
	lockGetKeyBytes  sync.RWMutex
	lockGetKeyInt64  sync.RWMutex
	lockGetKeyString sync.RWMutex
	lockSetKey       sync.RWMutex
}

// GetKeyBytes calls GetKeyBytesFunc.
func (mock *CacheMock) GetKeyBytes(s string) ([]byte, bool) {
	if mock.GetKeyBytesFunc == nil {
		panic("CacheMock.GetKeyBytesFunc: method is nil but Cache.GetKeyBytes was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockGetKeyBytes.Lock()
	mock.calls.GetKeyBytes = append(mock.calls.GetKeyBytes, callInfo)
	mock.lockGetKeyBytes.Unlock()
	return mock.GetKeyBytesFunc(s)
}

// GetKeyBytesCalls gets all the calls that were made to GetKeyBytes.
// Check the length with:
//     len(mockedCache.GetKeyBytesCalls())
func (mock *CacheMock) GetKeyBytesCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockGetKeyBytes.RLock()
	calls = mock.calls.GetKeyBytes
	mock.lockGetKeyBytes.RUnlock()
	return calls
}

// GetKeyInt64 calls GetKeyInt64Func.
func (mock *CacheMock) GetKeyInt64(s string) (int64, bool) {
	if mock.GetKeyInt64Func == nil {
		panic("CacheMock.GetKeyInt64Func: method is nil but Cache.GetKeyInt64 was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockGetKeyInt64.Lock()
	mock.calls.GetKeyInt64 = append(mock.calls.GetKeyInt64, callInfo)
	mock.lockGetKeyInt64.Unlock()
	return mock.GetKeyInt64Func(s)
}

// GetKeyInt64Calls gets all the calls that were made to GetKeyInt64.
// Check the length with:
//     len(mockedCache.GetKeyInt64Calls())
func (mock *CacheMock) GetKeyInt64Calls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockGetKeyInt64.RLock()
	calls = mock.calls.GetKeyInt64
	mock.lockGetKeyInt64.RUnlock()
	return calls
}

// GetKeyString calls GetKeyStringFunc.
func (mock *CacheMock) GetKeyString(s string) (string, bool) {
	if mock.GetKeyStringFunc == nil {
		panic("CacheMock.GetKeyStringFunc: method is nil but Cache.GetKeyString was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockGetKeyString.Lock()
	mock.calls.GetKeyString = append(mock.calls.GetKeyString, callInfo)
	mock.lockGetKeyString.Unlock()
	return mock.GetKeyStringFunc(s)
}

// GetKeyStringCalls gets all the calls that were made to GetKeyString.
// Check the length with:
//     len(mockedCache.GetKeyStringCalls())
func (mock *CacheMock) GetKeyStringCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockGetKeyString.RLock()
	calls = mock.calls.GetKeyString
	mock.lockGetKeyString.RUnlock()
	return calls
}

// SetKey calls SetKeyFunc.
func (mock *CacheMock) SetKey(s string, ifaceVal interface{}, duration time.Duration) error {
	if mock.SetKeyFunc == nil {
		panic("CacheMock.SetKeyFunc: method is nil but Cache.SetKey was just called")
	}
	callInfo := struct {
		S        string
		IfaceVal interface{}
		Duration time.Duration
	}{
		S:        s,
		IfaceVal: ifaceVal,
		Duration: duration,
	}
	mock.lockSetKey.Lock()
	mock.calls.SetKey = append(mock.calls.SetKey, callInfo)
	mock.lockSetKey.Unlock()
	return mock.SetKeyFunc(s, ifaceVal, duration)
}

// SetKeyCalls gets all the calls that were made to SetKey.
// Check the length with:
//     len(mockedCache.SetKeyCalls())
func (mock *CacheMock) SetKeyCalls() []struct {
	S        string
	IfaceVal interface{}
	Duration time.Duration
} {
	var calls []struct {
		S        string
		IfaceVal interface{}
		Duration time.Duration
	}
	mock.lockSetKey.RLock()
	calls = mock.calls.SetKey
	mock.lockSetKey.RUnlock()
	return calls
}
